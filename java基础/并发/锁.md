## 锁
### 什么是锁
- 并发环境下，多个线程会对同一个资源进行争抢，会导致数据不一致的问题，为此编程语言引入锁机制。通过抽象的锁对资源进行锁定。在java中每个object都存在一把锁，锁存在与对象头中。java中每个对象包含三个部分，对象头，实例数据，填充字节。对齐填充字节是为了满足java对象的大小必须是8比特的倍数而设计的。实例数据包含属性，方法。对象头存放对象运行时信息包含两部分，mark word：当前对象运行时信息，如hashcode，锁标识位；class point ：指针指向当前对象类型锁在方法区忠德对象类型
### synchronized
- synchronized 被javac编译后会生成monitorenter和monitorexit字节码指令，依赖这两个指令进行线程同步，在这两个指令之间包裹的就是需要执行同步的代码。
- synchronized 会存在性能问题，编译后生成的两条字节码指令，是依赖于操作系统的，mutex lock实现，java线程实际上是对操作系统线程的映射，所以每当挂起或者唤醒一个线程，都涉及内核态和用户态之间的切换，是重量级的，某些情况下，切换时间可能超过任务执行时间。
- java 6 开始引入了 偏向锁，轻量级锁。所以markword 标识位锁总共分为4种状态：01无锁-标识位0，01偏向锁，00轻量级锁，10重量级锁，就对应了mark word中的四种状态。锁只能升级不能降级。



#### 无锁
- 不会出现竞争
- CAS 在编程中通过一条指令来实现， 保证原子性，无锁编程
#### 偏向锁
- 理想情况下 不通过mutex lock线程切换，也不通过cas获取锁
- 在mark wrod中
#### 轻量级锁
#### 重量级锁

### 怎样保证线程安全？
- 使用锁保证线程安全，如sychronized、volite、ReentryLock。
### volite两个特性是什么？
-volite的两个特性是可见性和禁止指令重排序。可见性是线程在获取volite属性时，需要去主内存刷新数据到线程内存中，写数据要去更新到主内存中。禁止指令重排序最经典的例子是单例的DCL，由于创建对象分为3个步骤，分配内存空间，初始化成员属性和构造方法，将引用指向内存空间，。由于Java是乱序执行，在多线程环境，创建对象的第二步最后执行，会出现对象已经不为空，但是调用使用它的属性去调用方法会崩溃，因为此时还没有初始化成员属性。
### sychronized和volite有什么区别？
- sychronized仅有获得锁的当前线程访问，其他线程不能访问。volite所有线程都可以访问，需要从主内存渎值。
- sychronized可以作用在类、方法，代码块。volite可以作用在变量。
- sychronized保证原子性，volite不能保证原子性。
- sychronized会造成线程阻塞，volite不会造成线程阻塞。
- synchronized可以被编译器优化，volite不可以被编译器优化。
### 来了一个新任务，多线程是如何处理的？
- 多线程中会设置核心线程数，最大线程数，阻塞队列。其中核心线程数+非核心线程数=最大线程数。
- 1.来一个任务，看是否有空闲核心线程。有执行在核心线程。
- 2.如果核心线程数已满，是否还可以加入阻塞队列，阻塞队列不满加入阻塞队列。
- 3.如果阻塞队列已满，是否有空闲的非核心线程。有执行在非核心线程。
- 4.如果没有空闲的非核心线程，我们使用拒绝策略拒绝这个任务。
