## 线程
### 线程和进程的区别
- 进程——资源分配的最小单位，线程——程序执行的最小单位
- 进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
- 进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
- 调度和切换：线程上下文切换，比进程上下文切换要快得多。
### 进程间通讯
- 管道、消息队列、共享内存、信号量、网络、文件
### 线程间通讯 
- volatile 和 synchronized 关键字 、等待 / 通知机制 、管道输入/ 输出流 、Thread.join() 的使用 、ThreadLocal
### 操作系统的内核线程
- Linux 进程实际上是 轻量级进程，进程有独立的地址空间，轻量级进程没有独立的地址空间，只能共享同一个轻量级进程组下的地址空间。进程和轻量级进程都是使用clone系统调用，区别是传的参数不同。
### 三种线程模型
- 一对一 ：一般直接使用API或系统调用创建的线程均为一对一的线程。简单好用但是 并发量有限。
- 多对一 ：多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户的代码来进行。提升并发量和性能，但是一个用户阻塞其他用户都无法使用。
- 多对多 ：结合了多对一模型和一对一模型的特点，将多个用户线程映射到少数但不止一个内核线程上。解决一对一和多对一的缺点，但是实现难度高。

### 创建线程的方式？
- 1.继承Thread类。 该方法的好处是 this 代表的就是当前线程，无法规避java的单继承
- 2.实现Runnable接口。 该方法的好处是可以规避类的单继承的限制；但需要通过 Thread.currentThread() 来获取当前线程的引用
- 3.实现Callable接口。该种方法可以创建一个FutureTask对象来接收返回值

### 线程状态
- 线程通常有五种状态，创建，就绪，运行、阻塞和死亡状态。

#### 线程的阻塞
- 等待阻塞：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify或notifyAll方法才能被唤醒，wait是object类的方法
- 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。
- 其他阻塞：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。sleep是Thread类的方法。

### 锁池
- 所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配。

### 等待池
- 当我们调用wait（）方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中。

### sleep()、wait()
- sleep就是把cpu的执行资格和执行权释放出去，不再运行此线程，当定时时间结束再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了。而如果sleep时该线程有锁，那么sleep不会释放这个锁，而是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说无法执行程序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出interruptexception异常返回，这点和wait是一样的。
- sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。
- sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。
- sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。
- sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）。
- sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。

### yield()
- yield（）执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行

### join()
- join（）执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那线程B会进入到阻塞队列，直到线程A结束或中断线程

### 参考致谢
- https://blog.csdn.net/weixin_43947102/article/details/120649224