## 线程
### 线程和进程的区别
- 地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
- 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
- 调度和切换：线程上下文切换比进程上下文切换要快得多。
### 进程间通讯
- 管道、消息队列、共享内存、信号量、网络、文件
### 线程间通讯 
- volatile 和 synchronized 关键字 、等待 / 通知机制 、管道输入/ 输出流 、Thread.join() 的使用 、ThreadLocal
####操作系统的内核线程
- Linux 进程实际上是 轻量级进程，进程有独立的地址空间，轻量级进程没有独立的地址空间，只能共享同一个轻量级进程组下的地址空间。进程和轻量级进程都是使用clone系统调用，区别是传的参数不同。
### 三种线程模型
- 一对一 ：一般直接使用API或系统调用创建的线程均为一对一的线程。简单好用但是 并发量有限。
- 多对一 ：多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户的代码来进行。提升并发量和性能，但是一个用户阻塞其他用户都无法使用。
- 多对多 ：结合了多对一模型和一对一模型的特点，将多个用户线程映射到少数但不止一个内核线程上。解决一对一和多对一的缺点，但是实现难度高。
## 锁
### 什么是锁
- 并发环境下，多个线程会对同一个资源进行争抢，会导致数据不一致的问题，为此编程语言引入锁机制。通过抽象的锁对资源进行锁定。在java中每个object都存在一把锁，锁存在与对象头中。java中每个对象包含三个部分，对象头，实例数据，填充字节。对齐填充字节是为了满足java对象的大小必须是8比特的倍数而设计的。实例数据包含属性，方法。对象头存放对象运行时信息包含两部分，mark word：当前对象运行时信息，如hashcode，锁标识位；class point ：指针指向当前对象类型锁在方法区忠德对象类型
### synchronized 
- synchronized 被javac编译后会生成monitorenter和monitorexit字节码指令，依赖这两个指令进行线程同步，在这两个指令之间包裹的就是需要执行同步的代码。
- synchronized 会存在性能问题，编译后生成的两条字节码指令，是依赖于操作系统的，mutex lock实现，java线程实际上是对操作系统线程的映射，所以每当挂起或者唤醒一个线程，都涉及内核态和用户态之间的切换，是重量级的，某些情况下，切换时间可能超过任务执行时间。
- java 6 开始引入了 偏向锁，轻量级锁。所以markword 标识位锁总共分为4种状态：01无锁-标识位0，01偏向锁，00轻量级锁，10重量级锁，就对应了mark word中的四种状态。锁只能升级不能降级。



#### 无锁
- 不会出现竞争
- CAS 在编程中通过一条指令来实现， 保证原子性，无锁编程
#### 偏向锁
- 理想情况下 不通过mutex lock线程切换，也不通过cas获取锁
- 在mark wrod中 
#### 轻量级锁
#### 重量级锁




### 创建线程的方式？
- 1.继承Thread类。 2.实现Runnable接口。 3.实现Callable接口。
### 怎样保证线程安全？
- 使用锁保证线程安全，如sychronized、volite、ReentryLock。
### volite两个特性是什么？
-volite的两个特性是可见性和禁止指令重排序。可见性是线程在获取volite属性时，需要去主内存刷新数据到线程内存中，写数据要去更新到主内存中。禁止指令重排序最经典的例子是单例的DCL，由于创建对象分为3个步骤，分配内存空间，初始化成员属性和构造方法，将引用指向内存空间，。由于Java是乱序执行，在多线程环境，创建对象的第二步最后执行，会出现对象已经不为空，但是调用使用它的属性去调用方法会崩溃，因为此时还没有初始化成员属性。
### sychronized和volite有什么区别？
- sychronized仅有获得锁的当前线程访问，其他线程不能访问。volite所有线程都可以访问，需要从主内存渎值。
- sychronized可以作用在类、方法，代码块。volite可以作用在变量。
- sychronized保证原子性，volite不能保证原子性。
- sychronized会造成线程阻塞，volite不会造成线程阻塞。
- synchronized可以被编译器优化，volite不可以被编译器优化。
### 来了一个新任务，多线程是如何处理的？
- 多线程中会设置核心线程数，最大线程数，阻塞队列。其中核心线程数+非核心线程数=最大线程数。
- 1.来一个任务，看是否有空闲核心线程。有执行在核心线程。
- 2.如果核心线程数已满，是否还可以加入阻塞队列，阻塞队列不满加入阻塞队列。
- 3.如果阻塞队列已满，是否有空闲的非核心线程。有执行在非核心线程。
- 4.如果没有空闲的非核心线程，我们使用拒绝策略拒绝这个任务。
