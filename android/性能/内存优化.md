## 读懂了内存，就读懂了程序
![img.png](resource/运行时.png)

### JVM堆区的基本原理
![img.png](resource/堆区数据结构.png)
#### 小对象10k，几百k的对象怎么创建出来的
- 小的对象会放到Eden区，该区满了后，会执行Minor-GC，把Eden区能回收的对象都回收掉，不能回收的放到to区里面
- 当再次满了后，再次执行Minor-GC，这次会扫Eden区和to区，找到中间不能回收的放到from区。
- 如果from或to区里面分带年龄达到了阈值比如ART虚拟机GC扫描了6次，这个对象就会进老年代。
- 老年代满了，进行Full-GC。
- GC工作会引起STW现象，会造成卡顿
- GC调优，单个程序申请内存增大，减少GC回收次数
#### 回收算法
- 标记：可达性分析：GCRoot 其实是对象头上面有个1或0来标识的；如果引用链上有个对象放到了栈或方法区，他就不能回收。所以直接查对象头就好。
- ![img.png](resource/可达性分析.png)
- ![img.png](resource/对象头.png)
- 回收：老年代标记清除算法：老年代比较稳定，碎片少。如果出现4k碎片，再申请5k空间会直接抛OOM，所以OOM不仅是内存满了才会溢出。
- 回收：年轻代复制算法，复制完后，格式化原有存储空间，速度快，无碎片


### 常见内存问题：主要处理抖动和泄漏
#### 1.OOM引发原因
- a.内存不够用
- b.申请空间在内存中无连续内存空间
#### 2.内存抖动
- a.内存频繁申请回收
- b.申请次数太多会引发GC，同时还会引起卡顿
- c.申请速度过快
#### 3.内存泄漏
- 长引短：长生命周期对象持有了一个短生命周期对象的强引用：某个对象持有activity引用，activity退出的时候，这个对象还未释放，从而导致整个activity引用链不释放。




### 如何验证堆区原理有效性 VisualGC
- 该工具把堆区的各个部分大小，里面存储内容的大小试试展示

### 内存分析工具使用profile MAT
- top/procrank
- meminfo
- ddms
- MAT
- LeakCannary 非activity问题 就很难排查



### 第三方SDK与系统的内存泄漏怎么处理


### 解决内存问题最有效的方案

### 引发内存问题常见的十种优化